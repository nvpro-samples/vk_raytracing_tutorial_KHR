/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */
 
#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#include "raycommon.glsl"
#include "SH_hash_tools.glsl"


const int GROUP_SIZE = 16;
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;
layout(set = 0, binding = 0, rgba32f) uniform image2D inImage;
layout(set = 0, binding = 1, r32f) uniform image2D outImage;


layout(scalar, set = 0, binding = 2) buffer HashMap {
    HashCell hashMap[HASH_MAP_SIZE];
};

layout(set = 0, binding = 3) uniform UniformBuffer {
    ConfigurationValues config;
};


// See AoControl
layout(push_constant) uniform params_
{
  float rtao_radius;
  int   rtao_samples;
  float rtao_power;
  int   rtao_distance_based;
  int   frame_number;
  int   max_samples;
};

//get the values for each pixel from the hash map and store in texture
void main()
{
  float ao    = 0.0;

  // Retrieving position and normal
  vec4 gBuffer = imageLoad(inImage, ivec2(gl_GlobalInvocationID.xy)); //ivec2(uv.x * config.res.x, uv.y * config.res.y));

  // Shooting rays only if a fragment was rendered
  if(gBuffer != vec4(0))
  {
    vec3 position = gBuffer.xyz;
    vec3 normal = DecompressUnitVec(floatBitsToUint(gBuffer.w));
    
    float s_wd = s_wd_calc(config, position);

    // Sample coarser levels when not enough samples
    const int min_nr_samples = 80;
    uint current_samples = 0;
    
    for(int l = 0; l < 5; ++l){
        
        float s_wd_it = s_wd * pow2[l];

        uint hash = H7D_SWD(config, position, normal, s_wd_it) % HASH_MAP_SIZE;
        uint checksum = H7D_SWD_checksum(config, position, normal, s_wd_it);

        for(int i = 0; i < LINEAR_SEARCH_LENGTH; ++i){

            HashCell read_cell_i = hashMap[hash + i];

            if(read_cell_i.checksum == checksum){

                current_samples += read_cell_i.contribution_counter;
                ao += read_cell_i.ao_value;
                break;
            }
        }

        if(current_samples >= min_nr_samples){
            // Enough samples => stop finding more values
            break;
        }
    }

    ao /= current_samples;
  }

  imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(ao));
}
 