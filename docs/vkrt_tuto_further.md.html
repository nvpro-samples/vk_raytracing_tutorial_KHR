

## [Jitter Camera (Anti-Aliasing)](vkrt_tuto_jitter_cam.md.htm)

Anti-aliases the image by accumulating small variations of rays over time. 

* Random ray direction generation
* Read/write/accumulate final image

![Antialising](Images/antialiasing.png height= "300px")

## [Handle Thousands of Objects](vkrt_tuto_instances.md.htm)  

The current example allocates memory for each object, each of which has several buffers.
This shows how to get around Vulkan's limits on the total number of memory allocations by using a memory allocator.

* Extend the limit of 4096 memory allocations
* Using memory allocators: DMA, VMA

![20000 'unique' object](Images/VkInstances.png height= "300px") 

## [Any Hit Shader (Transparency)](vkrt_tuto_anyhit.md.htm)

Implements transparent materials by adding a new shader to the Hit group and using the material
information to discard hits over time.

* Adding anyhit (.ahit) to the ray tracing pipeline
* Randomly letting the ray hit or not which is making simple transparency 

![One usage of anyhit shader](Images/anyhit.png height= "300px") 


## [Reflections](vkrt_tuto_reflection.md.htm)

Reflections can be implemented by shooting new rays from the closest hit shader, or by iteratively shooting them from
the raygen shader. This example shows the limitations and differences of these implementations.

* Calling traceRayEXT() from the closest hit shader (recursive)
* Adding more data to the ray payload to continue the ray from the raygen shader. 

![Hundread of Reflections](Images/reflections.png height= "300px") 


## [Multiple Closest Hits Shader and Shader Records](vkrt_tuto_manyhits.md.htm)

Explains how to add more closest hit shaders, choose which instance uses which shader, and add data per SBT that can be
retrieved in the shader, and more.

* One closest hit shader per object
* Sharing closest hit shaders for some object
* Passing shader record to closest hit shader 

![Different Closest Hit and Shader Record](Images/manyhits.png height= "300px") 


## [Animation](vkrt_tuto_animation.md.htm)

This tutorial shows how animating the transformation matrices of the instances (TLAS) 
and animating the vertices of an object (BLAS) in a compute shader, could be done.

* Refit of top level acceleration structure
* Refit of bottom level acceleration structure

![TLAS and BLAS Animation](Images/animation2.gif height= "300px") 


## [Intersection Shader](vkrt_tuto_intersection.md.html)

Adding thousands of implicit primitives and using an intersection shader to render spheres and cubes. The tutorial
explains what is needed to get procedural hit group working.

* Intersection Shader
* Sphere intersection
* Axis aligned bounding box intersection

![Intersection Shader with Spheres and Cubes](Images/ray_tracing_intersection.png height= "300px")



## [Callable Shader](vkrt_tuto_callable.md.html)

Replacing if/else by callable shaders. The code to execute the lighting is done in separate callable shaders instead of been part of the code.

* Adding multiple callable shaders
* Calling ExecuteCallableEXT from  the closest hit shader

![Infinite | Spot | Point from callable shaders](Images/callable.png height= "300px")




## [Ray Query](vkrt_tuto_rayquery.md.htm)

Invoking ray intersection queries directly from the fragment shader to cast shadow rays.

* Ray tracing directly from the fragment shader

![Ray Query](Images/rayquery.png height= "300px")


<!-- Markdeep: -->
<link rel="stylesheet" href="vkrt_tutorial.css?">
<script> window.markdeepOptions = { tocStyle: "medium" };</script>
<script src="markdeep.min.js" charset="utf-8"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js" charset="utf-8"></script>
<script>
    window.alreadyProcessedMarkdeep || (document.body.style.visibility = "visible")
</script>
